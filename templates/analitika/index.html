<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MedoedAI - üìä –ê–Ω–∞–ª–∏—Ç–∏–∫–∞</title>
    <link rel="stylesheet" href="/static/css/styles.css">
    <link rel="stylesheet" href="/static/css/sidebar.css">
    <link rel="stylesheet" href="/static/css/tabs.css">
</head>
<body>
    {% include 'include/_sidebar.html' %}

    <button class="mobile-menu-btn" onclick="toggleSidebar()">‚ò∞</button>

    <div class="container">
        <div class="main-content">
            <div class="header">
                <h1>üìä –ê–Ω–∞–ª–∏—Ç–∏–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤</h1>
                <p>–í—ã–±–µ—Ä–∏—Ç–µ —Å–∏–º–≤–æ–ª –∏ run (result/&lt;SYMBOL&gt;/runs/&lt;run_id&gt;)</p>
                <div class="button-group" style="margin-top: 12px;">
                    <a href="/" class="btn btn-secondary">‚¨Ö –ù–∞ –≥–ª–∞–≤–Ω—É—é</a>
                </div>
            </div>

            <div class="content">
                <div id="analytics-section" class="section">
                    <div class="form-group">
                        <label>–¢–∏–ø –º–æ–¥–µ–ª–∏</label>
                        <select id="modelTypeSelect" onchange="reloadSymbolsForModelType()">
                            <option value="dqn" selected>ü§ñ DQN</option>
                            <option value="sac">üåå SAC</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>–°–∏–º–≤–æ–ª</label>
                        <select id="indexSymbolSelect"></select>
                    </div>
                    <div class="form-group">
                        <label>Run (UUID)</label>
                        <select id="indexRunSelect"></select>
                    </div>
                    <div class="form-group" style="display: none;">
                        <label>–§–∞–π–ª—ã —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ (legacy)</label>
                        <select id="resultsFileSelect"></select>
                    </div>
                    <div class="button-group">
                        <button id="listResultsBtn" class="btn btn-info" onclick="loadIndexSymbols()">üìã –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫</button>
                        <button id="analyzeResultsBtn" class="btn btn-primary" onclick="analyzeTrainingResultsSelected()">üìà –ê–Ω–∞–ª–∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤</button>
                        <button id="analyzeBadTradesBtn" class="btn btn-warning" onclick="analyzeBadTradesSelected()">üîç –ü–ª–æ—Ö–∏–µ —Å–¥–µ–ª–∫–∏</button>
                    </div>
                </div>

                <div class="section">
                    <div id="indexRunInfo" class="status info" style="display:none; white-space: pre-line;"></div>
                    <div id="analysisStatus" class="status" style="display: none;"></div>
                    <div id="analysisResults" class="results" style="display: none;"></div>
                    <div id="filesList" class="results" style="display: none;"></div>
                </div>

                <div class="section">
                    <div id="badTradesStatus" class="status" style="display: none;"></div>
                    <div id="badTradesSummary" class="results" style="display: none;"></div>
                    <div id="badTradesResults" class="results" style="display: none;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –æ–±—É—á–µ–Ω–∏—è –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω—ã —Å –≥–ª–∞–≤–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        let indexRunsBySymbol = {};

        async function parseJsonResponse(response) {
            const text = await response.text();
            const trimmed = (typeof text === 'string') ? text.trim() : '';
            if (!response.ok) {
                // –ü–æ–¥—Ä–æ–±–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ 404 –¥–ª—è SAC API
                if (response.status === 404 && trimmed.startsWith('<!doctype')) {
                    throw new Error('–≠–Ω–¥–ø–æ–∏–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω (404). –í–æ–∑–º–æ–∂–Ω–æ, —Å–µ—Ä–≤–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç SAC-–∞–Ω–∞–ª–∏—Ç–∏–∫—É.');
                }
                const detail = trimmed ? trimmed.slice(0, 200) : (response.statusText || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞');
                throw new Error(`HTTP ${response.status}: ${detail}`);
            }
            try {
                return JSON.parse(text);
            } catch (err) {
                const detail = trimmed.slice(0, 200);
                throw new Error(`–û—Ç–≤–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞ –Ω–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON${detail ? `: ${detail}` : ''}`);
            }
        }

        function reloadSymbolsForModelType(){
            indexRunsBySymbol = {};
            const runSel = document.getElementById('indexRunSelect');
            if(runSel){ runSel.innerHTML = '<option value="">‚Äî</option>'; }
            loadIndexSymbols();
        }

        function getSelectedModelType(){
            return (document.getElementById('modelTypeSelect')?.value || 'dqn').trim().toLowerCase();
        }

        async function loadIndexSymbols(){
            const sel = document.getElementById('indexSymbolSelect');
            const runSel = document.getElementById('indexRunSelect');
            if(!sel) return;
            try{
                const modelType = getSelectedModelType();
                const apiBase = (modelType === 'sac') ? '/api/sac' : '';
                const resp = await fetch(`${apiBase}/api/runs/symbols?model_type=${encodeURIComponent(modelType)}`);
                const data = await resp.json();
                const symbols = (data && data.success && Array.isArray(data.symbols))? data.symbols: [];
                sel.innerHTML = symbols.length?
                    symbols.map(s=>{
                        const value = typeof s === 'string' ? s : (s.value || s.label || '');
                        if(!value) return '';
                        let label = typeof s === 'string' ? s : (s.label || s.value);
                        if(value.toUpperCase().startsWith('SAC:')){
                            label = value.split(':')[1] || label;
                        }
                        return `<option value="${value}">${label}</option>`;
                    }).filter(Boolean).join('')
                    : '<option value="">–ù–µ—Ç —Å–∏–º–≤–æ–ª–æ–≤</option>';
                if(symbols.length){ await loadIndexRuns(); }
                else if(runSel){ runSel.innerHTML = '<option value="">‚Äî</option>'; }
            }catch(e){ if(sel) sel.innerHTML = '<option value="">–û—à–∏–±–∫–∞</option>'; }
        }

        async function loadIndexRuns(){
            const selEl = document.getElementById('indexSymbolSelect');
            const rawSymbol = selEl ? selEl.value : '';
            let sym = (rawSymbol || '').trim();
            const modelType = getSelectedModelType();
            if (modelType === 'sac' && sym.toUpperCase().startsWith('SAC:')) {
                sym = sym.split(':', 2)[1] || sym;
            }
            const runSel = document.getElementById('indexRunSelect');
            if(!sym || !runSel) return;
            try{
                const apiBase = (modelType === 'sac') ? '/api/sac' : '';
                const resp = await fetch(`${apiBase}/api/runs/list?model_type=${encodeURIComponent(modelType)}&symbol=${encodeURIComponent(sym)}`);
                const data = await resp.json();
                const runs = (data && data.success && Array.isArray(data.runs))? data.runs: [];
                const symbolDir = runs.length ? (runs[0].symbol_dir || sym) : sym;
                indexRunsBySymbol[rawSymbol] = { list: runs, modelType, symbolDir };
                runSel.innerHTML = runs.length? runs.map(r=>`<option value="${r.run_id}">${r.run_id}</option>`).join(''): '<option value="">–ù–µ—Ç run–æ–≤</option>';
                try{ await showIndexRunInfo(); }catch(_){ }
            }catch(e){ runSel.innerHTML = '<option value="">–û—à–∏–±–∫–∞</option>'; }
        }

        function getSelectedTrainResultPath(){
            const symRaw = document.getElementById('indexSymbolSelect')?.value || '';
            const sym = symRaw.trim();
            const runId = (document.getElementById('indexRunSelect')?.value||'').trim();
            const entry = indexRunsBySymbol[symRaw] || indexRunsBySymbol[sym.replace(/^SAC:/i, '')] || null;
            const runs = entry?.list || [];
            const modelType = getSelectedModelType();
            const symbolDir = entry?.symbolDir || sym.replace(/^SAC:/i, '');
            const found = runs.find(r=>r.run_id===runId);
            if(found && found.result_path){ return found.result_path; }
            if(sym && runId){
                if(modelType === 'sac'){
                    return `result/sac/${symbolDir.toLowerCase()}/runs/${runId}/train_result.pkl`;
                }
                return `result/dqn/${symbolDir}/runs/${runId}/train_result.pkl`;
            }
            return '';
        }

        async function showIndexRunInfo(){
            const infoDiv = document.getElementById('indexRunInfo');
            if(!infoDiv) return;
            const symRaw = document.getElementById('indexSymbolSelect')?.value || '';
            const sym = symRaw.trim();
            const runId = (document.getElementById('indexRunSelect')?.value||'').trim();
            if(!sym || !runId){ infoDiv.style.display='none'; return; }
            const entry = indexRunsBySymbol[symRaw] || indexRunsBySymbol[sym.replace(/^SAC:/i, '')] || null;
            const modelType = getSelectedModelType();
            const symbolDir = entry?.symbolDir || sym.replace(/^SAC:/i, '');
            const basePath = modelType === 'sac' ? `result/sac/${symbolDir.toLowerCase()}` : `result/dqn/${symbolDir}`;
            const runs = entry?.list || [];
            const found = runs.find(r=>r.run_id===runId);
            const modelPath = found?.model_path || `${basePath}/runs/${runId}/model.pth`;
            try{
                const resp = await fetch('/get_result_model_info', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ filename: modelPath, model_type: modelType }) });
                const result = await resp.json();
                if(!result.success){
                    infoDiv.className = 'status error';
                    infoDiv.textContent = '‚ùå ' + (result.error || '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏');
                    infoDiv.style.display = 'block';
                    return;
                }
                const stats = result.stats || {};
                const winrate = typeof stats.winrate === 'number' ? (stats.winrate * 100).toFixed(1) + '%' : 'N/A';
                const plr = typeof stats.pl_ratio === 'number' ? stats.pl_ratio.toFixed(2) : 'N/A';
                const trades = (stats.trades_count != null) ? stats.trades_count : 'N/A';
                const episodes = (result.episodes != null) ? result.episodes : 'N/A';
                const plannedEpisodes = (result.episodes_planned != null) ? result.episodes_planned : '‚Äî';
                const episodeLength = (result.episode_length != null) ? result.episode_length : null;
                const bestWinrate = (typeof result.best_winrate === 'number') ? (result.best_winrate * 100).toFixed(1) + '%' : 'N/A';
                const episodeWinrateSummary = result.episode_winrate_summary || null;
                const validationSummary = result.validation_summary || null;
                const seedFromList = found?.seed;
                const seed = seedFromList != null
                    ? seedFromList
                    : (result.train_metadata && result.train_metadata.seed != null)
                        ? result.train_metadata.seed
                        : (result.cfg_snapshot && result.cfg_snapshot.seed != null)
                            ? result.cfg_snapshot.seed
                            : (result.seed ?? '‚Äî');
                const cfgSeed = (result.cfg_snapshot && result.cfg_snapshot.seed != null) ? result.cfg_snapshot.seed : null;
                const gpu = (result.cuda_available===true) ? (result.gpu_name || 'GPU') : (result.cuda_available===false ? 'CPU' : '‚Äî');
                const totalTime = (typeof result.total_training_time === 'number') ? result.total_training_time : null;
                const avgTime = (typeof result.avg_time_per_episode_sec === 'number') ? result.avg_time_per_episode_sec : (totalTime && episodes ? (totalTime/episodes) : null);
                const fmtSec = (s)=>{ if(!s && s!==0) return 'N/A'; try{ const m=Math.floor(s/60), r=Math.round(s%60); return (m>0?`${m}–º `:'')+`${r}—Å`; }catch(_){ return s.toFixed? s.toFixed(1)+'—Å' : String(s); } };

                const lines = [];
                lines.push(`–°–∏–º–≤–æ–ª: ${symbolDir.toUpperCase()}`);
                lines.push(`Run: ${runId}`);
                const dir = (result.direction || found?.direction || '').toString().trim().toLowerCase();
                if (dir === 'long' || dir === 'short') {
                    lines.push(`–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: ${dir.toUpperCase()}`);
                }
                lines.push(`Seed: ${seed}`);
                if (episodeLength !== null && episodeLength !== undefined) {
                    lines.push(`–î–ª–∏–Ω–∞ —ç–ø–∏–∑–æ–¥–∞ (—à–∞–≥–æ–≤): ${episodeLength}`);
                }
                lines.push(`–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: ${gpu}`);
                lines.push(`–≠–ø–∏–∑–æ–¥–æ–≤ (—Ñ–∞–∫—Ç/–ø–ª–∞–Ω): ${episodes} / ${plannedEpisodes}`);
                lines.push(`Winrate: ${winrate}`);
                lines.push(`–õ—É—á—à–∏–π winrate: ${bestWinrate}`);
                if (episodeWinrateSummary && typeof episodeWinrateSummary.count === 'number') {
                    const avgWr = (typeof episodeWinrateSummary.avg === 'number') ? (episodeWinrateSummary.avg * 100).toFixed(1) + '%' : 'N/A';
                    const lastWr = (typeof episodeWinrateSummary.last === 'number') ? (episodeWinrateSummary.last * 100).toFixed(1) + '%' : 'N/A';
                    lines.push(`Winrate —ç–ø–∏–∑–æ–¥–æ–≤: avg ${avgWr}, last ${lastWr} (${episodeWinrateSummary.count} —ç–ø.)`);
                }
                lines.push(`P/L Ratio: ${plr}`);
                lines.push(`–°–¥–µ–ª–æ–∫: ${trades}`);
                if (validationSummary && typeof validationSummary.count === 'number') {
                    const avgVal = (typeof validationSummary.avg === 'number') ? validationSummary.avg.toFixed(2) : 'N/A';
                    const lastVal = (typeof validationSummary.last === 'number') ? validationSummary.last.toFixed(2) : 'N/A';
                    lines.push(`–í–∞–ª–∏–¥–∞—Ü–∏—è: avg ${avgVal}, last ${lastVal} (${validationSummary.count} —á–µ–∫–æ–≤)`);
                }
                lines.push(`–ë—É—Ñ–µ—Ä: ${result.replay_exists ? '‚úÖ –µ—Å—Ç—å' : '‚ùå –Ω–µ—Ç'}`);
                lines.push(`–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ–±—É—á–µ–Ω–∏—è: ${result.train_result_exists ? '‚úÖ –µ—Å—Ç—å' : '‚ùå –Ω–µ—Ç'}`);
                lines.push(`–°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –∑–∞ —ç–ø–∏–∑–æ–¥: ${fmtSec(avgTime)}`);
                lines.push(`–û–±—â–µ–µ –≤—Ä–µ–º—è –æ–±—É—á–µ–Ω–∏—è: ${totalTime ? fmtSec(totalTime) : 'N/A'}`);
                lines.push(`–ú–æ–¥–µ–ª—å: ${result.model_file ? result.model_file.split('/').pop().split('\\').pop() : 'N/A'}`);
                lines.push(`–ü—É—Ç—å –∫ –º–æ–¥–µ–ª–∏: ${result.model_path || result.model_file || '‚Äî'}`);
                lines.push(`–ü—É—Ç—å –∫ –±—É—Ñ–µ—Ä—É: ${result.buffer_path || result.replay_file || '‚Äî'}`);
                lines.push(`–†–µ–∑—É–ª—å—Ç–∞—Ç—ã: ${result.train_result_file ? result.train_result_file.split('/').pop().split('\\').pop() : '‚Äî'}`);
                infoDiv.className = 'status info';
                infoDiv.innerText = lines.join('\n');
                infoDiv.style.display = 'block';
            }catch(e){
                infoDiv.className = 'status error';
                infoDiv.textContent = '‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ç–∏: ' + e.message;
                infoDiv.style.display = 'block';
            }
        }

        async function listTrainingResults() {
            const statusDiv = document.getElementById('analysisStatus');
            const filesDiv = document.getElementById('filesList');
            const selectEl = document.getElementById('resultsFileSelect');
            const listBtn = document.getElementById('listResultsBtn');
            
            listBtn.disabled = true;
            listBtn.textContent = '‚è≥ –ü–æ–∏—Å–∫ —Ñ–∞–π–ª–æ–≤...';
            statusDiv.style.display = 'block';
            statusDiv.className = 'status running';
            statusDiv.textContent = 'üîç –ü–æ–∏—Å–∫ —Ñ–∞–π–ª–æ–≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –æ–±—É—á–µ–Ω–∏—è...';
            
            try {
                const response = await fetch('/list_training_results', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                const result = await parseJsonResponse(response);
                
                if (result.success) {
                    statusDiv.className = 'status success';
                    statusDiv.textContent = '‚úÖ ' + result.message;
                    filesDiv.style.display = 'block';
                    
                    let filesText = `üìã –î–û–°–¢–£–ü–ù–´–ï –§–ê–ô–õ–´ –†–ï–ó–£–õ–¨–¢–ê–¢–û–í:\n`;
                    filesText += `=====================================\n\n`;
                    
                    if (result.files && result.files.length > 0) {
                        selectEl.innerHTML = '';
                        for (const file of result.files) {
                            const opt = document.createElement('option');
                            opt.value = file.filename;
                            const date = new Date(file.created * 1000).toLocaleString();
                            const sizeKB = (file.size / 1024).toFixed(1);
                            opt.textContent = `${file.filename} (${sizeKB} KB, ${date})`;
                            selectEl.appendChild(opt);
                        }
                        for (const file of result.files) {
                            const date = new Date(file.created * 1000).toLocaleString();
                            const sizeKB = (file.size / 1024).toFixed(1);
                            filesText += `üìÑ ${file.filename}\n`;
                            filesText += `   üìÖ –°–æ–∑–¥–∞–Ω: ${date}\n`;
                            filesText += `   üìè –†–∞–∑–º–µ—Ä: ${sizeKB} KB\n\n`;
                        }
                    } else {
                        if (selectEl) {
                            selectEl.innerHTML = '';
                            const opt = document.createElement('option');
                            opt.value = '';
                            opt.textContent = '–ù–µ—Ç —Ñ–∞–π–ª–æ–≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤';
                            selectEl.appendChild(opt);
                        }
                        filesText += `‚ùå –§–∞–π–ª—ã —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã\n`;
                        filesText += `üí° –°–Ω–∞—á–∞–ª–∞ –∑–∞–ø—É—Å—Ç–∏—Ç–µ –æ–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏\n`;
                    }
                    
                    filesDiv.innerHTML = `<pre>${filesText}</pre>`;
                    
                } else {
                    throw new Error(result.message);
                }
                
            } catch (error) {
                statusDiv.className = 'status error';
                statusDiv.textContent = '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ —Ñ–∞–π–ª–æ–≤: ' + error.message;
            } finally {
                listBtn.disabled = false;
                listBtn.textContent = 'üìã –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫';
            }
        }

        async function analyzeTrainingResultsSelected() {
            let file = getSelectedTrainResultPath();
            if(!file){
                const selectEl = document.getElementById('resultsFileSelect');
                file = selectEl? (selectEl.value||'') : '';
            }

            const modelType = getSelectedModelType();
            const analyzeBtn = document.getElementById('analyzeResultsBtn');
            const statusDiv = document.getElementById('analysisStatus');
            const resultsDiv = document.getElementById('analysisResults');
            analyzeBtn.disabled = true;
            statusDiv.style.display = 'block';
            statusDiv.className = 'status running';
            statusDiv.textContent = 'üìä –ê–Ω–∞–ª–∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –æ–±—É—á–µ–Ω–∏—è...';

            console.log('[Analytics] modelType =', modelType, 'file =', file);

            try {
                let url;
                let payload;

                if (modelType === 'sac') {
                    url = '/api/sac/analyze_training_results';
                    payload = { file };
                    console.log('[Analytics] SAC endpoint', url);
                } else {
                    url = '/analyze_training_results';
                    payload = { file, model_type: modelType };
                    console.log('[Analytics] DQN endpoint', url);
                }

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                console.log('[Analytics] Response status =', response.status);

                const result = await parseJsonResponse(response);
                if (result.success) {
                    statusDiv.className = 'status success';
                    statusDiv.textContent = '‚úÖ ' + result.message;
                    resultsDiv.style.display = 'block';
                    let analysisText = `üìä –ê–ù–ê–õ–ò–ó –§–ê–ô–õ–ê\n===============================\n\n`;
                    analysisText += `üìÑ –§–∞–π–ª: ${result.file_analyzed}\n`;
                    if (Array.isArray(result.summaries) && result.summaries.length) {
                        analysisText += `\nüîç –°–≤–æ–¥–∫–∞:\n`;
                        analysisText += result.summaries.map(line => `  ‚Ä¢ ${line}`).join('\n');
                        analysisText += '\n';
                    }
                    const outputText = (result.output && result.output.trim()) ? result.output : '–ù–µ—Ç –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –≤—ã–≤–æ–¥–∞ –∞–Ω–∞–ª–∏–∑–∞.';
                    analysisText += outputText;
                    resultsDiv.innerHTML = `<pre>${analysisText}</pre>`;
                } else {
                    throw new Error(result.message);
                }
            } catch (e) {
                console.error('[Analytics] –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞:', e);
                statusDiv.className = 'status error';
                statusDiv.textContent = '‚ùå –û—à–∏–±–∫–∞: ' + e.message;
            } finally {
                analyzeBtn.disabled = false;
            }
        }

        async function analyzeBadTradesSelected() {
            let file = getSelectedTrainResultPath();
            if(!file){
                const selectEl = document.getElementById('resultsFileSelect');
                file = selectEl? (selectEl.value||'') : '';
            }
            const entry = indexRunsBySymbol[document.getElementById('indexSymbolSelect')?.value || ''];
            const modelType = entry?.modelType || getSelectedModelType();
            const analyzeBtn = document.getElementById('analyzeBadTradesBtn');
            const statusDiv = document.getElementById('badTradesStatus');
            const resultsDiv = document.getElementById('badTradesResults');
            const summaryDiv = document.getElementById('badTradesSummary');
            analyzeBtn.disabled = true;
            statusDiv.style.display = 'block';
            statusDiv.className = 'status running';
            statusDiv.textContent = 'üîç –ê–Ω–∞–ª–∏–∑ –ø–ª–æ—Ö–∏—Ö —Å–¥–µ–ª–æ–∫...';
            resultsDiv.style.display = 'none';
            summaryDiv.style.display = 'none';
            try {
                const response = await fetch('/analyze_bad_trades', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ file, model_type: modelType })
                });
                const result = await parseJsonResponse(response);
                if (result.success) {
                    statusDiv.className = 'status success';
                    statusDiv.textContent = '‚úÖ ' + result.message;
                    summaryDiv.style.display = 'block';
                    let summaryText = `üìä –°–í–û–î–ö–ê –ü–õ–û–•–ò–• –°–î–ï–õ–û–ö\n===============================\n\n`;
                    summaryText += `üìÑ –§–∞–π–ª: ${result.file_analyzed.split('/').pop()}\n`;
                    summaryText += `üî¢ –ü–ª–æ—Ö–∏—Ö —Å–¥–µ–ª–æ–∫: ${result.bad_trades_count} (${result.bad_trades_percentage.toFixed(2)}%)\n`;
                    summaryDiv.innerHTML = `<pre>${summaryText}</pre>`;
                    resultsDiv.style.display = 'block';
                    const badTradesOutput = (result.output && result.output.trim()) ? result.output : '–ù–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–µ—Ç–∞–ª–µ–π.';
                    resultsDiv.innerHTML = `<pre>${badTradesOutput}</pre>`;
                } else {
                    throw new Error(result.message);
                }
            } catch (e) {
                statusDiv.className = 'status error';
                statusDiv.textContent = '‚ùå –û—à–∏–±–∫–∞: ' + e.message;
            } finally {
                analyzeBtn.disabled = false;
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            try {
                loadIndexSymbols();
                const symSel = document.getElementById('indexSymbolSelect');
                if (symSel) { symSel.addEventListener('change', loadIndexRuns); }
                const runSel = document.getElementById('indexRunSelect');
                if (runSel) { runSel.addEventListener('change', showIndexRunInfo); }
            } catch (e) {
                console.error(e);
            }
        });
    </script>
    <script src="/static/js/sidebar.js"></script>
</body>
</html>
