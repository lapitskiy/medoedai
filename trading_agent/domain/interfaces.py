from __future__ import annotations

from typing import Protocol, Optional, Dict, Any, Tuple

from .models import Intent, LimitConfig, Side, IntentState


class ExecutionStrategy(Protocol):
    """
    Интерфейс стратегии исполнения торгового намерения (intent).
    Каждая стратегия независима и инкапсулирует собственную механику (market, limit_post_only, ...).
    """

    def place_intent(self, symbol: str, side: Side, qty: float, cfg: Optional[LimitConfig] = None) -> Intent:  # noqa: D401
        """Создаёт intent и размещает стартовый ордер (если требуется стратегией)."""

    def run_until_done(self, intent: Intent) -> Intent:  # noqa: D401
        """Запускает цикл исполнения до терминального состояния (FILLED/CANCELLED/FAILED/EXPIRED)."""

    def cancel_intent(self, intent_id: str) -> None:  # noqa: D401
        """Отменяет intent (и связанные биржевые ордера)."""


class StateStore(Protocol):
    """Порт хранилища состояния (Redis)."""

    def save_intent(self, intent: Intent) -> None: ...
    def load_intent(self, intent_id: str) -> Optional[Intent]: ...
    def update_intent(self, intent: Intent) -> None: ...
    def set_state(self, intent_id: str, state: IntentState, last_error: Optional[str] = None) -> None: ...
    def append_log(self, intent_id: str, price: Optional[float], event: str, reason: Optional[str] = None) -> None: ...
    def bump_attempts(self, intent_id: str, delta: int = 1) -> None: ...

    def add_pending(self, symbol: str, intent_id: str) -> None: ...
    def remove_pending(self, symbol: str, intent_id: str) -> None: ...
    def has_active_intent(self, symbol: str) -> bool: ...


class ExchangeGateway(Protocol):
    """Порт доступа к бирже (REST/WS)."""

    # REST helpers
    def get_tick_size(self, symbol: str) -> float: ...
    def get_best_bid_ask(self, symbol: str) -> Tuple[float, float]: ...

    def place_limit_post_only(self, symbol: str, side: Side, qty: float, price: float) -> Dict[str, Any]: ...
    def amend_order(self, symbol: str, order_id: str, price: float) -> Dict[str, Any]: ...
    def cancel_order(self, symbol: str, order_id: str) -> None: ...
    def get_order_status(self, symbol: str, order_id: str) -> Dict[str, Any]: ...

    # WS lifecycle
    def connect_ws(self) -> None: ...
    def subscribe_orders(self, symbol: str, on_event: callable) -> None: ...
    def subscribe_ticker(self, symbol: str, on_event: callable) -> None: ...


